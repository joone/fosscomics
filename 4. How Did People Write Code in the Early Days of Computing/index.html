<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Nanum+Pen+Script&family=Playpen+Sans:wght@100..800&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="../styles/fonts.css">
        <link rel="stylesheet" href="../styles/main.css">
        <link rel="icon" type="image/png" href="../images/favicon.png">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-M0CWE9F5HJ"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag("js", new Date());
          gtag("config", "G-M0CWE9F5HJ");
        </script>
        <title>4. How Did People Write Code in the Early Days of Computing?</title>
        <meta name="description" content="In the early days of computing, programming was done at the hardware level, with functionality embedded in circuits. ENIAC, for example, ran programs by manual rewiring. With the advent of stored-program computers like EDVAC and EDSAC, programming involved writing machine code, a binary language difficult for humans. Assembly language, using mnemonics for machine instructions, simplified the process. Programmers wrote code on paper, debugged it mentally, then transferred it to punch cards for execution, a tedious process that involved waiting for machine time and results..." />

        <meta property="og:type" content="article" />
        <meta property="og:site_name" content="F/OSS Comics" />
        <meta property="og:url" content="https://fosscomics.com/4. How Did People Write Code in the Early Days of Computing/" />
        <meta property="og:title" content="4. How Did People Write Code in the Early Days of Computing?" />
        <meta property="og:description" content="In the early days of computing, programming was done at the hardware level, with functionality embedded in circuits. ENIAC, for example, ran programs by manual rewiring. With the advent of stored-program computers like EDVAC and EDSAC, programming involved writing machine code, a binary language difficult for humans. Assembly language, using mnemonics for machine instructions, simplified the process. Programmers wrote code on paper, debugged it mentally, then transferred it to punch cards for execution, a tedious process that involved waiting for machine time and results..." />
        <meta property="og:image" content="https://fosscomics.com/4. How Did People Write Code in the Early Days of Computing/images/feature.png" />
        <meta property="article:author" content="Joone Hur" />
        <meta property="article:published_time" content="2022-12-03" />
        <meta property="article:tag" content="Assembly Language">
        <meta property="article:tag" content="EDSAC">
        <meta property="article:tag" content="ENIAC">
        <meta property="article:tag" content="Fortran">
        <meta property="article:tag" content="Machine Code">
        <meta property="article:tag" content="Multics">
        <meta property="article:tag" content="Punch Card">

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@fosscomics" />
        <meta name="twitter:creator" content="@joone" />
        <meta name="twitter:title" content="4. How Did People Write Code in the Early Days of Computing?" />
        <meta name="twitter:description" content="In the early days of computing, programming was done at the hardware level, with functionality embedded in circuits. ENIAC, for example, ran programs by manual rewiring. With the advent of stored-program computers like EDVAC and EDSAC, programming involved writing machine code, a binary language difficult for humans. Assembly language, using mnemonics for machine instructions, simplified the process. Programmers wrote code on paper, debugged it mentally, then transferred it to punch cards for execution, a tedious process that involved waiting for machine time and results..." />
        <meta name="twitter:image" content="https://fosscomics.com/4. How Did People Write Code in the Early Days of Computing/images/feature.png" />
    </head>
    <body>
        <div class="content">
            <header>
                <div class="main">
                  F/OSS Comics
                </div>
                <nav class="site-navigation">
                  <a href="/">Home</a>
                  <a href="/all_posts">All posts</a>
                  <a href="/about">About</a>
                  <a href="/tags">Tags</a>
                </nav>
            </header>
            <main>
              <article class="content">
                  <div class="title">
                    <h1 class="title">4. How Did People Write Code in the Early Days of Computing?</h1>
                    <div class="meta">Posted on Dec 3, 2022</div>
                  </div>
                  <section class="body">
                    <p>When computers were first introduced commercially, how did people write code for computers? In fact, there was no software similar to what we have today. All functionalities were implemented as functional units in circuits. <a href="https://en.wikipedia.org/wiki/ENIAC ">ENIAC</a> was also able to run various programs by wiring each functional unit and used punch cards as a storage device<a href="http://www.seas.upenn.edu/about-seas/eniac/operation.php "title="Celebrating Penn Engineering History: ENIAC">&#91;1&#93;</a>.</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_1.png" alt="" style="width: 80%;">
            
          </figure>
        </div>
      <div class="blockquote-container"><blockquote><p>&quot;This is a computer for arithmetic operations&quot;<br>“That is a computer for breaking German ciphers”</p></blockquote></div>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_2.png" alt="" style="width: 80%;">
            
          </figure>
        </div>
      <div class="blockquote-container"><blockquote><p>&quot;Can I make a computer for ballistics calculation?&quot;<br>&quot;How many relays and vacuum tubes are needed for this?&quot;</p></blockquote></div><p>Actual computer programming has been possible since stored-program computers such as <a href="https://en.wikipedia.org/wiki/EDVAC ">EDVAC</a> and <a href="https://en.wikipedia.org/wiki/EDSAC ">EDSAC</a> were introduced in 1949. Basically, the program can be executed after it is loaded into memory.</p><p>A program is made up of instructions that the machine can understand, which is called <a href="https://en.wikipedia.org/wiki/Machine_code ">machine code</a>. The machine language is difficult for humans to understand because it consists only of binary numbers such as 0 and 1.</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_3.png" alt="Neo scans binary numbers" style="width: 70%;">
            
          </figure>
        </div>
      <p>So, that’s why assembly language was born in the early age of computer programming. For example,  the users wrote executable code on EDSAC using an assembly language called Initial Orders. This is an example of an assembly language used in EDSAC<a href="http://www.cl.cam.ac.uk/~mr10/edsacposter.pdf "title="EDSAC Initial Orders and Squares Program">&lbrack;2&rbrack;</a>.</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_4.png" alt="" style="width: 80%;">
            
          </figure>
        </div>
      <p>All machine language instructions used in EDSAC are composed of 17 bits. The first column is the operation code, and the second column, 1 bit, is not used. Third column is the operand, representing the address. The last bit indicates whether the current instruction is 17 bits or 35 bits.</p><p>What does mnemonic, TOS, mean? It means that it loads the value of the accumulator A into m[0]  and then initializes the accumulator A. The second command H is that it loads the multiplier register R with the data in m[2].</p><p>As you can see, machine code is just binary code so it’s difficult for humans to easily understand and remember it. Therefore, assembly language is used to represent each low-level instruction or opcode with mnemonics. When assembly language is converted into machine code, we call it assembling</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_5.png" alt="">
            
          </figure>
        </div>
      <p>In the early days, assembling was done by hand, so the term, hand assembling, was used. Assembly language has been around since the 1950s. The early programmers must know how to use assembly language because there was no high-level language at the time.</p><p> If there is no assembly tool, you still have to assemble assembly code manually by looking at the mnemonic conversion table.</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_11.png" alt="" style="width: 70%;">
            
          </figure>
        </div>
      <div class="blockquote-container"><blockquote><p>&quot;I’m writing code&quot;</p></blockquote></div><p>However, keyboards and monitors did not become commercially available until the 1960s. The first computer with a monitor and keyboard was Multics, which was jointly developed by Bell Labs and MIT in 1964<a href="http://theinventors.org/library/inventors/blcomputer_keyboard.htm "title="History of the Computer Keyboard">&lbrack;3&rbrack;</a>, and in the 1970s, most computers had a terminal with a screen and keyboard. Then, how could programmers write code and check the results without a monitor and keyboard in the 1960s.</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_6.png" alt="" style="width: 70%;">
            
          </figure>
        </div>
      <div class="blockquote-container"><blockquote><p>&quot;Finally, I got a computer with a keyboard and a monitor&quot;</p></blockquote></div><p>Early programmers used punched cards to write code. Punch cards were originally used for data storage from the late 19th century, and were used by the US Census Bureau for census purposes. It is easy to understand if you think of the current <a href="https://en.wikipedia.org/wiki/Optical_mark_recognition ">OMR</a> sheet to mark answers.</p><p>IBM had developed a punch card system at the time and was supplying the system worldwide so  the punch card was well used as an essential part of early programming.</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_7.png" alt="" style="width: 60%;">
            <figcaption>Punch card for Fortran programming</figcaption>
          </figure>
        </div>
      <p>For example, the early programmers used punch cards as a development tool. First, the programmer wrote assembly code on paper. Then they debugged by running the code in their minds. When they were convinced that there were no more errors in their code. Finally, the code was hand assembled into machine code and they filled out machine code line by line onto a punch card.</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_8.png" alt="" style="width: 70%;">
            <figcaption>IBM 026 keypunch machine</figcaption>
          </figure>
        </div>
      <div class="blockquote-container"><blockquote><p>“I need to write the code on the punch card”</p></blockquote></div><p>Programmers took the punch card to the operator of the computer room.The operator put the punch card into the punch card reader and the computer was able to execute the code loaded from the punch card reader. In reality, the programmer had to wait in line to hand the punch card to the operator and wait a long time until they received the execution result. If there is something wrong with the result, they had to do the same things over and over to get the result they wanted.</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_9.png" alt="">
            
          </figure>
        </div>
      <div class="blockquote-container"><blockquote><p>&quot;Can you take a look at my code?&quot;<br>&quot;Next person&quot;</p></blockquote></div><p>The interesting thing is that just copying a punch card is the same as copying a program, so it was possible to copy programs by writing at the time.</p>
        <div style="text-align: center;">
          <figure style="text-align: center;">
            <img src="images/4_10.png" alt="" style="width: 70%;">
            
          </figure>
        </div>
      <h2>References</h2>
<ol>
<li><a href="http://www.seas.upenn.edu/about-seas/eniac/operation.php ">Celebrating Penn Engineering History: ENIAC</a></li>
<li><a href="http://www.cl.cam.ac.uk/~mr10/edsacposter.pdf ">EDSAC Initial Orders and Squares Program</a></li>
<li><a href="http://theinventors.org/library/inventors/blcomputer_keyboard.htm ">History of the Computer Keyboard</a></li>
</ol>

                  </section>
                  <div class="post-tags">
                    <nav class="nav tags">
                      <ul class="tags">
                        <li><a href="/tags/Assembly_Language">Assembly Language</a></li><li><a href="/tags/EDSAC">EDSAC</a></li><li><a href="/tags/ENIAC">ENIAC</a></li><li><a href="/tags/Fortran">Fortran</a></li><li><a href="/tags/Machine_Code">Machine Code</a></li><li><a href="/tags/Multics">Multics</a></li><li><a href="/tags/Punch_Card">Punch Card</a></li>
                      </ul>
                    </nav>
                  </div>
              </article>
              <ul class="pagination-post" role="navigation">
                <span class="page-item page-prev">
                <a href="../3. The Era of Commercial Computers" class="page-link" aria-label="Previous">← 3. The Era of Commercial Computers</a>
                </span>
                <span class="page-item page-next">
                <a href="../5. The Beginning of Software Engineering" class="page-link" aria-label="Next">5. The Beginning of Software Engineering →</a>
                </span>
              </ul>
              <div class="comments border">
                <script src="https://utteranc.es/client.js"
                            repo="joone/fosscomics"
                            issue-term="pathname"
                            theme="github-light"
                            crossorigin="anonymous"
                            async>
                </script>
              </div>
            </main>

            <footer>
              <div style="display:flex">
                <a class="soc" href="https://github.com/joone/fosscomics" rel="me" title="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a>
                <a class="border"></a><a class="soc" href="https://twitter.com/@fosscomics" rel="me" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a>
                <a class="border"></a>
              </div>
              <div class="footer-info">
                © 2024 Joone Hur | <a href="https://github.com/joone/fosscomics">fosscomics v1.1.18</a> | Published on Apr 17, 2024
              </div>
            </footer>
        </div>
    </body>
</html>